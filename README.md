# 카프카 공부를 위한 Repository(Kafka: The Definitive Guide)

## File Setting

1. [Confluent Cloud Console](https://confluent.cloud/home)에서 클러스터 생성
2. **API keys** 섹션으로 가서 API key 생성
3. **Topics** 섹션으로 가서 topic 생성 (테스트를 위해 purchases 생성)
4. poetry로 **my_kafka_project** 프로젝트 생성 
   - `petry add confluent-kafka`
5. **getting_started.ini** 파일 세팅

## 3장

- 카프카에 메시지를 쓰려면 3개의 필수 속상값을 가지는 프로듀서 객체를 생성해야한다.
  - bootstrap.servers: 카프카 클러스터와 첫 연결을 생성하기 위해 프로듀서가 사용할 브로커의 host:port 목록이다.
    - 브로커 중 하나가 작동을 정지하는 경우에도 프로듀서가 클러스터에 연결할 수 있도록 최소 2개 이상을 지정할 것을 권장한다. 
  - key.serializer: 카프카에 쓸 레코드의 키의 값을 직렬화하기 위해 사용하는 시리얼라이저 클래스의 이름이다.
  - value.serializer: 카프카에 쓸 레코드의 밸류값을 직렬화하기 위해 사용하는 시리얼라이저 클래스의 이름이다.
- 스키마 레지스트리
  - 개요: 카프카는 프로듀서가 메시지를 보낸 후 컨슈머가 소비하려고 할 때 누가 보낸 메시지인지 확인할 수 있는 방법이 없다. 그래서 Producer가 메시지를 기존에 보내던 것과 다른 스키마 형식으로 보낸다면 Consumer는 바뀐 메시지를 받았을 때 문제가 크게 발생할 수도 있다.
  - 스키마 레지스트리는 프로듀서와 컨슈머가 주고 받으려는 메시지의 스키마를 서로 알게 해주고 호환을 강제한다
  - Consumer는 카프카 로부터 바이너리 데이터를 받는데, 이 데이터에는 스키마 ID 가 포함되어 ID를 통해 스키마 레지스트리에서 스키마 정보를 가져와서 사용한다.
  - 장점
    - 잘못된 스키마를 가진 메시지를 전달하고자 한다면 스키마 레지스트리에 등록되는 과정에서 실패가 되고, 카프카에 메시지가 전달되지 않는다.
    - 스키마의 버전관리가 가능해진다.
  - 단점
    - 스키마 레지스트리 서버를 관리해야한다.(운영포인트 증가)
    - 스키마 레지스트리에 장애가 발생하는 경우 정상적으로 메시지를 전달하지 못한다. 
- 파티션
  - 기본 파티셔너 사용할 때 키값이 Null인 레코드가 주어지면 토픽의 파티션 중 하나에 랜덤으로 저장한다.
  - 각 파티션별로 저장되는 메시지 개수의 균형을 맞추기 위해 라운드로빈 알고리즘이 사용된다.
- 헤더
  - 헤더는 카프카 레코드의 key/value 값을 건드리지 않고 추가 메타데이터를 심을 때 사용한다.
    - 메시지의 전달 내역을 기록하는 것이 주된 용도
    - 데이터가 생성된 곳의 정보를 헤더에 저장해두면, 메시지를 파싱 할 필요 없이 헤더에 심어진 정보만으로 메시지를 라우팅하거나 출처를 추적할 수 있다.
- 인터셉터
  - 카프카 클라이언트 코드를 고치지 않으면서 작동을 변경해야 하는 경우에 사용한다.
  - onSend
    - 프로듀서가 레코드를 브로커로 보내기 전, 직렬화되기 직전에 호출된다. 
    - 메서드를 재정의할 때는 보내질 레코드에 담긴 정보를 볼 수 있고 고칠 수도 있다. 
    - 이 메서드를 통해서 유효한 ProducerRecord를 리턴하도록 하게 하면 된다. 
    - 리턴 한 레코드를 직렬화해서 카프카로 보내진다.
  - onAcknowledgement 
    - 카프카 브로커가 보낸 응답을 클라이언트가 받았을 때 호출된다. 
    - 브로커가 보낸 응답을 변경할 수는 없지만, 담긴 정보는 읽을 수 있다.
- 쿼터, 스로틀링
  - 카프카 브로커에는 쓰기/읽기 속도를 제한할 수 있는 기능이 있다. 
  - 쓰기 쿼터, 읽기 쿼터, 요청 쿼터 3가지 타입에 대해 한도를 설정할 수 있다. 
    - 쓰기 쿼터, 읽기 쿼터 
      - 클라이언트가 데이터를 전송하거나 받는 속도를 초당 바이트 수 단위로 제한한다. 
    - 요청 쿼터 
      - 브로커가 요청을 처리하는 시간 비율 단위로 제한한다.