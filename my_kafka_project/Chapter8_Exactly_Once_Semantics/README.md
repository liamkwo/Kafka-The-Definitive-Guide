## **정확히 한 번** 의미 구조

카프카의 **정확히 한 번** 의미 구조는 두 개의 핵심 기능인 <span style='color:#f7b731'>멱등적 프로듀서(idempotent producer)</span>와 <span style='color:#f7b731'>트랜잭션 의미 구조</span>의 조합으로 이루어 진다.

- **멱등적 프로듀서**는 재시도로 인해 발생하는 중복을 방지한다.
- **트랜잭션 의미 구조**는 스트림 처리 애플리케이션에서 <span style='color:#f7b731'>정확히 한 번 처리를 보장</span>한다.



### 멱등적 프로듀서

동일한 작업을 여러 번 실행해도 한번 실행한 것과 같은 결과가 같은 서비스를 **멱등적**이라고 한다. 데이터베이스에서는 흔히 다음과 같이 설명한다.

1. `UPDATE t SET x=x+1 where y=5
	- 멱등적이지 않음. 1을 세 번 호출하면 한 번 호출한 것과 결과가 다르다.
2. `UPDATE t SET x=18 where y=5`
	- 멱등적이다. 몇 번을 호출하든 x는 18이다.


카프카 프로듀서는 <span style='color:#f7b731'>멱등성 의미 구조가 아닌 최소 한 번의 의미 구조를 가지도록 프로듀서를 설정한다면</span>, 프로듀서가 메시지 전송을 재시도함으로써 메시지가 최소 한 번 이상 도착할 수 있는 불확실성이 존재하게 된다. 즉, **중복을 발생**시킬 수 있다. 이것의 고전적인 예시는 다음과 같이 설명할 수 있다.

1. 파티션 리더가 프로듀서로부터 레코드를 받아서 팔로워들에게 성공적으로 복제한다.
2. 프로듀서에게 응답을 보내기 전, 파티션 리더가 잇는 브로커에 크래시가 발생한다.
3. 프로듀서 입장에서는 응답을 받지 못한 채 타임아웃이 발생하고, 메시지를 재전송한다.
4. 재전송된 메시지가 새 리더에게 도착하는데, 이 메시지는 이미 저장되어져 있다.

카프카의 멱등적 프로듀서 기능은 자동으로 이러한 중복을 탐지하고 처리함으로써 이 문제를 해결한다.


#### 멱등적 프로듀서의 작동 원리

1. 멱등적 프로듀서 기능을 키면 모든 메시지는 고유한 **프로듀서 ID(producer ID, PID)** 와 **시퀀스 넘버(sequence ID)** 를 가지게 된다.
2. <span style='color:#f7b731'>대상 토픽 및 파티션과 이 두 값을 합치면</span> 각 메시지의 **고유한 식별자**가 된다.
3. 각 브로커는 해당 브로커에 할당된 모든 파티션들에 쓰여진 마지막 5개 메시지들을 추적하기 위해 이 고유 식별자를 사용한다.
	- 파티션별로 추적되어야 하는 시퀀스 넘버의 수를 제한하고 싶다면 프로듀서의 `max.in.flights.requests.per.connection` 설정 값이 5 이하로 잡혀 있어야 한다.
4. 브로커가 예전에 받은 적이 있는 메시지를 받게 될 경우, 적절한 에러를 발생시킴으로써 중복 메시지를 거부한다.
	- 이 에러는 프로듀서에 로깅도 되고 지푯값에도 반영되지만, 예외가 발생한 것은 아니기 때문에 사용자에게 정보를 보내지는 않는다.
	- 프로듀서 클라이언트에서는 <span style='color:#f7b731'>record-error-rate 지푯값</span>을 확인함으로써 에러를 확인할 수 있다.
5. 만약 브로커가 예상보다 높은 시퀀스 넘버를 받게 된다면, <mark style='background:#8854d0'>'out of order sequence number'</mark> 에러를 발생시킨다.
	- 트랜잭션 기능 없이 멱등적 프로듀서만 사용하고 있다면 이 에러는 무시해도 된다.

 > <mark style='background:#8854d0'>'out of order sequence number'</mark> 에러가 발생한 뒤에도 프로듀서가 정상 작동한다면, 이 에러는 보통 프로듀서와 브로커 사이에 메시지 유실이 있었음을 의미한다. 만약 브로커가 2번 메시지 다음 27번을 받았다면, 3번 부터 26번까지 뭔가가 일어난 것이다. 로그에 이러한 에러가 찍혀있다면, **프로듀서와 브로커 설정을 재점검**하고 **프로듀서 설정이 고신뢰성을 위해 권장되는 값으로 잡혀있는지**, 아니면 **언클린 리더 선출이 발생했는지** 여부를 확인해야한다.

 
1️⃣ **프로듀서 재시작**

- 프로듀서에 장애가 발생할 경우, 보통 <span style='color:#f7b731'>새 프로듀서를 생성해서 장애가 난 프로듀서를 대체</span>한다.
- 프로듀서가 시작될 때 <span style='color:#f7b731'>멱등적 프로듀서 기능이 켜져 있을 경우</span>, 프로듀서는 초기화 과정에서 카프카 브로커로부터 **프로듀서 ID를 생성**한다.
- 트랜잭션 기능을 켜지 않았을 경우, 프로듀서를 초기화할 때마다 **완전히 새로운 ID를 생성**한다. 즉, 프로듀서에 장애가 발생해서 대신 투입된 새 프로듀서가 기존 프로듀서가 이미 전송한 메시지를 다시 전송할 경우, <span style='color:#f7b731'>브로커는 메시지에 중복이 발생했음을 알아채지 못한다.</span>
	- 두 메시지가 **서로 다른 프로듀서 ID**와 **시퀀스 넘버**를 갖는 만큼 서로 다른 것으로 취급한다.
	- <span style='color:#eb3b5a'>그럼 트랜잭션이 켜져있을 때도 새로운 프로듀서 ID를 발급하니깐 브로커는 중복을 발생여부를 모르는 건가?</span>


2️⃣ **브로커 장애**

브로커 장애가 발생할 경우, 컨트롤러는 장애가 난 브로커가 리더를 맡고 있었던 파티션들에 대해 **새 리더를 선출**한다. 그렇다면 새 리더는  어느 시퀀스 넘버까지 쓰였는지 어떻게 알까?

1. 리더는 새 메시지가 쓰여질 때마다 인-메모리 프로듀서 상태에 저장된 **최근 5개의 시퀀스 넘버를 업데이트**한다.
2. 팔로워는 <span style='color:#f7b731'>리더로부터 새로운 메시지를 복제할 때마다</span> **자체적인 인-메모리 버퍼를 업데이트**한다. 즉, 팔로워가 리더가 된 시점에는 이미 메모리 안에 최근 5개의 시퀀스 넘버를 가지고 있다.
3. 따라서 아무 이슈나 지연 없이, 새로 쓰여진 메시지의 유효성 검증이 재개될 수 있는 것이다.

하지만, 여기서 예전 리더가 다시 돌아온다면 어떤 일이 벌어질까?

1. <span style='color:#f7b731'>브로커는 종료되거나 새 세그먼트가 생성될 때마다</span> **프로듀서 상태에 대한 스냅샷을 파일 형태로 저장**한다.
2. 브로커가 시작되면 일단 파일에서 최신 상태를 읽어 온다.
3. 현재 리더로부터 복제한 레코드를 사용해서 **프로듀서 상태를 업데이트 함으로써 최신 상태를 복구**한다.
4. 그래서 이 브로커가 다시 리더를 맡을 준비가 될 시점에는 시퀀스 넘버를 가지고 있게 된다.

만약 브로커가 크래시 나서 최신 스냅샷이 업데이트되지 않는다면 어떻게 될까?

1. **프로듀서 ID**와 **시퀀스 넘버**는 둘 다 <span style='color:#f7b731'>카프카 로그에 저장되는 메시지 형식의 일부</span>다. 
2. 크래시 복구 작업이 진행되는 동안 프로듀서 상태는 더 오래 된 스냅샷뿐만 아니라 각 파티션 최신 세그먼트의 메시지들 역시 사용해서 복구된다.
3. 복구 작업이 완료되는 대로 **새로운 스냅샷 파일이 저장**된다.

만약 메시지가 없다면 어떻게 될까?

1. 보존 기한은 2시간인데 지난 두 시간동안 메시지가 하나도 들어오지 않은 토픽이 있다.(브로커가 크래시 날 경우, 프로듀서 상태를 복구하기 위해 사용할 수 있는 메시지 역시 없을 것이다.)
2. 다행히 **메시지가 없다는 얘기는 중복이 없다는 얘기**이다.
3. 이 경우 즉시 새 매시지를 받기 시작해서 새로 들어오는 메시지들을 기준으로 프로듀서 상태를 생성할 수 있다.


#### 멱등적 프로듀서의 한계

- 카프카의 멱등적 프로듀서의 내부 로직으로 인한 재시도가 발생할 경우 생기는 중복만을 방지한다.
- 동일한 메시지를 가지고 `producer.send()`를 두 번 호출하면 멱등적 프로듀서가 개입 하지 않는 만큼 중복된 메시지가 생기게 된다.
- 여러 개의 인스턴스를 띄우거나 하나의 인스턴스에서 여러 개의 프로듀서를 띄웠을 때, 이러한 프로듀서들 중 두 개가 동일한 메시지를 전송하려 시도할 경우, 멱등적 프로듀서는 중복을 잡아내지 못한다.

> 멱등적 프로듀서는 **프로듀서 자체의 재시도 메커니즘(프로듀서, 네트워크, 브로커 에러로 인해 발생하는)** 에 의한 중복만을 방지할 뿐, 그 이상은 하지 않는다.


#### 멱등적 프로듀서 사용법

프로듀서 설정에 `enable.idempotence=true`를 추가해준다.

- 만약 프로듀서에 `acks=all`설정이 이미 잡혀 있다면, 성능에는 큰 차이가 없을 것이다.
- Kafka 3.0 이후로는 defalut가 true이다.


멱등성 프로듀서 기능을 활성화시키면 바뀌는 것들

- 프로듀서 ID를 받아오기 위해 프로듀서 시동 과정에서 API를 하나 더 호출한다.
- 전송되는 각각의 레코드 배치에는 **프로듀서 ID와 배치 내 첫 메시지의 시퀀스 넘버가 포함**된다.
	- 각 메시지의 시퀀스 넘버는 첫 메시지의 시퀀스 넘버에 변화량을 더하면 나온다.
	- 이 새 필드들은 각 메시지에 96비트를 추가한다. 따라서 <span style='color:#f7b731'>대부분의 경우 작업 부하에 어떠한 오버헤드도 되지 않는다.</span>
		- 프로듀서 ID는 long 타입이고, 시퀀스 넘버는 integer 타입이다.
- 브로커들은 모든 프로듀서 인스턴스에서 들어온 레코드 배치의 **시퀀스 넘버를 검증해서 메시지 중복을 방지**한다.
- 장애가 발생하더라도 각 파티션에 쓰여지는 메시지들의 순서는 보장된다.



### 트랜잭션


